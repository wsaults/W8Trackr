---
phase: 21-infrastructure-migration
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - W8Trackr/Managers/MigrationManager.swift
  - W8Trackr/W8TrackrApp.swift
autonomous: false

must_haves:
  truths:
    - "App launches without data loss for existing users"
    - "Fresh installs use App Group container directly (no migration needed)"
    - "Migration runs in background without blocking app interaction"
    - "Migration failure notifies user and requires manual retry"
    - "CloudKit sync continues working after migration"
  artifacts:
    - path: "W8Trackr/Managers/MigrationManager.swift"
      provides: "Migration logic with status tracking"
      exports: ["MigrationManager", "MigrationStatus"]
      min_lines: 80
    - path: "W8Trackr/W8TrackrApp.swift"
      provides: "App entry point with migration integration"
      contains: "MigrationManager"
  key_links:
    - from: "W8Trackr/Managers/MigrationManager.swift"
      to: "NSPersistentStoreCoordinator.replacePersistentStore"
      via: "CloudKit-safe migration API"
      pattern: "replacePersistentStore"
    - from: "W8Trackr/W8TrackrApp.swift"
      to: "SharedModelContainer.sharedModelContainer"
      via: "Model container injection"
      pattern: "SharedModelContainer"
    - from: "W8Trackr/Managers/MigrationManager.swift"
      to: "WidgetCenter.shared.reloadAllTimelines"
      via: "Widget notification after migration"
      pattern: "reloadAllTimelines"
---

<objective>
Implement data migration from default SwiftData location to App Group container, preserving CloudKit sync integrity for existing users.

Purpose: Existing users must not lose data when updating to this version. The migration must use `replacePersistentStore` (not `migratePersistentStore`) to preserve CloudKit metadata and prevent data duplication.

Output: MigrationManager.swift with CloudKit-safe migration, updated W8TrackrApp.swift using SharedModelContainer
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-infrastructure-migration/21-RESEARCH.md
@.planning/phases/21-infrastructure-migration/21-CONTEXT.md
@.planning/phases/21-infrastructure-migration/21-01-SUMMARY.md
@W8Trackr/W8TrackrApp.swift
@W8Trackr/Shared/SharedModelContainer.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MigrationManager with CloudKit-Safe Migration</name>
  <files>
    W8Trackr/Managers/MigrationManager.swift
  </files>
  <action>
Create MigrationManager.swift following project conventions (@MainActor, @Observable):

```swift
import Foundation
import SwiftData
import CoreData
import WidgetKit

enum MigrationStatus: Equatable {
    case notNeeded      // Fresh install or already migrated
    case pending        // Migration needed but not started
    case inProgress     // Currently migrating
    case completed      // Successfully migrated
    case failed(String) // Migration failed with error message

    static func == (lhs: MigrationStatus, rhs: MigrationStatus) -> Bool {
        switch (lhs, rhs) {
        case (.notNeeded, .notNeeded),
             (.pending, .pending),
             (.inProgress, .inProgress),
             (.completed, .completed):
            return true
        case (.failed(let lhsMsg), .failed(let rhsMsg)):
            return lhsMsg == rhsMsg
        default:
            return false
        }
    }
}

@MainActor
@Observable
final class MigrationManager {
    private(set) var status: MigrationStatus = .pending

    // Store paths
    private let oldStoreURL: URL
    private let newStoreURL: URL

    init() {
        // Default SwiftData location (Application Support)
        oldStoreURL = URL.applicationSupportDirectory
            .appending(path: "default.store")

        // App Group location
        let fileManager = FileManager.default
        if let appGroupURL = fileManager.containerURL(
            forSecurityApplicationGroupIdentifier: SharedModelContainer.appGroupIdentifier
        ) {
            newStoreURL = appGroupURL.appending(path: "default.store")
        } else {
            // This shouldn't happen if entitlements are correct
            newStoreURL = oldStoreURL
        }
    }

    /// Check if migration is needed
    func checkMigrationNeeded() {
        let fileManager = FileManager.default

        // If new store already exists, migration not needed (already done or fresh install to App Group)
        if fileManager.fileExists(atPath: newStoreURL.path()) {
            status = .notNeeded
            return
        }

        // If old store doesn't exist, fresh install - no migration needed
        if !fileManager.fileExists(atPath: oldStoreURL.path()) {
            status = .notNeeded
            return
        }

        // Old store exists, new doesn't - migration needed
        status = .pending
    }

    /// Perform migration using CloudKit-safe replacePersistentStore
    ///
    /// CRITICAL: Must use replacePersistentStore, NOT migratePersistentStore
    /// migratePersistentStore strips CloudKit metadata causing data duplication
    func performMigration() async {
        guard status == .pending else { return }

        status = .inProgress

        do {
            // Perform migration on background thread since it involves file I/O
            try await Task.detached(priority: .userInitiated) { [oldStoreURL, newStoreURL] in
                // Create a temporary Core Data stack for migration
                // We use NSPersistentContainer because SwiftData doesn't expose
                // the replacePersistentStore API directly
                let container = NSPersistentContainer(name: "W8Trackr")

                // Configure WITHOUT CloudKit during migration to prevent:
                // 1. Sync attempts during file operations
                // 2. Hangs for users with iCloud disabled
                let description = NSPersistentStoreDescription(url: oldStoreURL)
                description.cloudKitContainerOptions = nil // CRITICAL
                container.persistentStoreDescriptions = [description]

                // Use replacePersistentStore which preserves CloudKit metadata
                try container.persistentStoreCoordinator.replacePersistentStore(
                    at: newStoreURL,
                    withPersistentStoreFrom: oldStoreURL,
                    type: .sqlite
                )
            }.value

            // Migration succeeded
            status = .completed

            // Notify widgets to reload (they can now access data)
            WidgetCenter.shared.reloadAllTimelines()

            // Note: Per CONTEXT.md, Claude decides on old data retention.
            // Decision: Keep old store as backup for this release.
            // Can be cleaned up in a future version after confirming migration success at scale.

        } catch {
            // Per CONTEXT.md: Do NOT retry automatically
            status = .failed(error.localizedDescription)
        }
    }

    /// Manual retry triggered by user
    func retryMigration() async {
        guard case .failed = status else { return }
        status = .pending
        await performMigration()
    }
}
```

Key implementation details:
1. Uses `replacePersistentStore` (NOT `migratePersistentStore`) to preserve CloudKit metadata
2. Disables CloudKit during migration to prevent sync during file operations
3. Runs file operations on background thread via Task.detached
4. Does NOT auto-retry on failure (per CONTEXT.md)
5. Notifies WidgetCenter after successful migration
6. Keeps old store as backup (can clean up in future version)
  </action>
  <verify>
1. Build succeeds
2. SwiftLint passes: `swiftlint lint --strict W8Trackr/Managers/MigrationManager.swift`
3. MigrationManager uses @MainActor and @Observable per project conventions
4. Uses replacePersistentStore (grep confirms no migratePersistentStore)
  </verify>
  <done>
- MigrationManager.swift created in W8Trackr/Managers/
- Uses @MainActor @Observable pattern per project conventions
- Uses replacePersistentStore for CloudKit-safe migration
- Disables CloudKit during migration to prevent sync issues
- Does not auto-retry on failure
- Notifies widgets after successful migration
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate Migration and SharedModelContainer into App</name>
  <files>
    W8Trackr/W8TrackrApp.swift
  </files>
  <action>
Update W8TrackrApp.swift to:
1. Check for and perform migration at launch
2. Use SharedModelContainer for the model container
3. Show migration status UI if needed (non-blocking)

Replace the current implementation:

```swift
import SwiftData
import SwiftUI
import WidgetKit

@main
struct W8TrackrApp: App {
    @AppStorage("hasCompletedOnboarding") private var hasCompletedOnboarding = false
    @State private var healthSyncManager = HealthSyncManager()
    @State private var migrationManager = MigrationManager()

    /// Skip onboarding during UI tests to allow screenshot automation
    private var isUITesting: Bool {
        ProcessInfo.processInfo.arguments.contains("-ui_testing")
    }

    init() {
        // Check migration status synchronously at init
        // This just checks file existence, doesn't do actual migration
        migrationManager.checkMigrationNeeded()
    }

    var body: some Scene {
        WindowGroup {
            Group {
                if hasCompletedOnboarding || isUITesting {
                    ContentView()
                } else {
                    OnboardingView {
                        // Callback when onboarding completes
                    }
                }
            }
            .task {
                // Perform migration in background if needed
                // App is usable while this runs (per CONTEXT.md)
                if migrationManager.status == .pending {
                    await migrationManager.performMigration()
                }
            }
            .overlay {
                // Show migration status banner if failed (requires manual retry)
                if case .failed(let message) = migrationManager.status {
                    migrationFailedBanner(message: message)
                }
            }
        }
        .environment(healthSyncManager)
        .environment(migrationManager)
        .modelContainer(SharedModelContainer.sharedModelContainer)
    }

    @ViewBuilder
    private func migrationFailedBanner(message: String) -> some View {
        VStack {
            Spacer()

            VStack(spacing: 12) {
                HStack(spacing: 8) {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .foregroundStyle(.yellow)
                    Text("Data Migration Failed")
                        .bold()
                }

                Text(message)
                    .font(.caption)
                    .foregroundStyle(.secondary)
                    .multilineTextAlignment(.center)

                Button("Retry Migration") {
                    Task {
                        await migrationManager.retryMigration()
                    }
                }
                .buttonStyle(.borderedProminent)
            }
            .padding()
            .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 16))
            .padding()
        }
    }
}
```

Key changes:
1. Added `@State private var migrationManager = MigrationManager()`
2. Call `migrationManager.checkMigrationNeeded()` in init
3. Use `.task` modifier to run migration in background (non-blocking per CONTEXT.md)
4. Replace `.modelContainer(for:)` with `.modelContainer(SharedModelContainer.sharedModelContainer)`
5. Inject migrationManager into environment for potential future use
6. Show migration failure banner with retry button (per CONTEXT.md: no auto-retry)

Note: The app remains usable during migration. Users with existing data will see their data once migration completes. The migration is fast (file copy) so typically completes before user notices.
  </action>
  <verify>
1. Build succeeds: `xcodebuild -project W8Trackr.xcodeproj -scheme W8Trackr -configuration Debug -sdk iphonesimulator build`
2. SwiftLint passes: `swiftlint lint --strict`
3. App uses SharedModelContainer.sharedModelContainer
4. MigrationManager is initialized and checked at launch
  </verify>
  <done>
- W8TrackrApp uses SharedModelContainer.sharedModelContainer for model container
- MigrationManager integrated and checked at launch
- Migration runs in background without blocking app interaction
- Migration failure shows banner with manual retry button
- App remains usable during and after migration
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete migration infrastructure from default SwiftData location to App Group container.

Components implemented:
1. MigrationManager with CloudKit-safe migration using replacePersistentStore
2. W8TrackrApp integration with SharedModelContainer
3. Non-blocking migration with failure banner UI
  </what-built>
  <how-to-verify>
**Testing migration requires a device or simulator with existing data.**

**Option A: Fresh install test (quick)**
1. Delete W8Trackr from simulator
2. Build and run the app
3. Complete onboarding, add a weight entry
4. Verify entry appears in the app
5. Check that app doesn't show migration failure banner

**Option B: Migration test (requires setup)**
1. Install a previous version of the app (if available) OR manually place a .store file in Application Support
2. Build and run the updated app
3. Verify existing data still appears
4. Verify no migration failure banner
5. Verify CloudKit sync still works (if testing on device with iCloud)

**Option C: Migration failure test**
1. Run app in debugger
2. Set breakpoint in MigrationManager.performMigration
3. Simulate failure by modifying the method temporarily
4. Verify failure banner appears
5. Verify retry button works

**Key verification points:**
- App launches without crash
- Existing data preserved (if migrating)
- No duplicate entries (CloudKit metadata preserved)
- Migration failure shows clear error with retry option
  </how-to-verify>
  <resume-signal>Type "approved" if migration works correctly, or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
1. Build succeeds: `xcodebuild -project W8Trackr.xcodeproj -scheme W8Trackr -configuration Debug -sdk iphonesimulator build`
2. SwiftLint passes with zero violations
3. MigrationManager uses replacePersistentStore (not migratePersistentStore)
4. W8TrackrApp uses SharedModelContainer
5. Manual testing confirms migration works on device with existing data
</verification>

<success_criteria>
- INFRA-02 complete: Existing users' SwiftData migrates to shared container without data loss
- Migration uses CloudKit-safe replacePersistentStore API
- Migration runs in background without blocking app interaction
- Migration failure notifies user with manual retry option
- Fresh installs work directly with App Group container
- CloudKit sync continues working after migration
</success_criteria>

<output>
After completion, create `.planning/phases/21-infrastructure-migration/21-02-SUMMARY.md`
</output>
