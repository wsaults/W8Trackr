---
phase: 22-widgets
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - W8TrackrWidget/W8TrackrWidget.swift
  - W8TrackrWidget/Views/SmallWidgetView.swift
  - W8TrackrWidget/Views/MediumWidgetView.swift
  - W8TrackrWidget/Views/LargeWidgetView.swift
  - W8TrackrWidget/Views/EmptyStateView.swift
  - W8Trackr/Views/AddWeightSheet.swift
  - W8Trackr/Views/EditWeightSheet.swift
  - W8Trackr/Views/SettingsView.swift
autonomous: true

must_haves:
  truths:
    - "Small widget displays current weight with trend arrow"
    - "Medium widget displays progress percentage toward goal"
    - "Large widget displays sparkline chart of recent entries"
    - "Widgets show helpful empty state when no data"
    - "Widgets update when user modifies data in app"
    - "Tapping any widget opens W8Trackr app"
  artifacts:
    - path: "W8TrackrWidget/Views/SmallWidgetView.swift"
      provides: "Small widget UI with weight and trend"
      contains: "widgetURL"
    - path: "W8TrackrWidget/Views/MediumWidgetView.swift"
      provides: "Medium widget UI with progress"
      contains: "widgetURL"
    - path: "W8TrackrWidget/Views/LargeWidgetView.swift"
      provides: "Large widget UI with sparkline chart"
      contains: "Chart"
    - path: "W8TrackrWidget/Views/EmptyStateView.swift"
      provides: "Empty state prompt for no data/no goal"
      contains: "Add your first"
  key_links:
    - from: "W8Trackr/Views/AddWeightSheet.swift"
      to: "WidgetCenter"
      via: "reloadTimelines call"
      pattern: "WidgetCenter.shared.reloadTimelines"
    - from: "W8Trackr/Views/EditWeightSheet.swift"
      to: "WidgetCenter"
      via: "reloadTimelines call"
      pattern: "WidgetCenter.shared.reloadTimelines"
    - from: "W8Trackr/Views/SettingsView.swift"
      to: "WidgetCenter"
      via: "reloadTimelines call on goal/unit change"
      pattern: "WidgetCenter.shared.reloadTimelines"
---

<objective>
Implement the three widget size views and integrate widget refresh into the main app.

Purpose: Create visually polished widget UIs that match W8Trackr's style and ensure widgets update immediately when users modify their weight data.

Output: Functional widgets (small, medium, large) that display weight data and refresh automatically.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/22-widgets/22-CONTEXT.md
@.planning/phases/22-widgets/22-RESEARCH.md
@.planning/phases/22-widgets/22-01-SUMMARY.md

@W8TrackrWidget/WeightWidgetEntry.swift
@W8TrackrWidget/W8TrackrWidget.swift
@W8Trackr/Views/AddWeightSheet.swift
@W8Trackr/Views/EditWeightSheet.swift
@W8Trackr/Views/SettingsView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Small and Medium Widget Views</name>
  <files>
    W8TrackrWidget/Views/SmallWidgetView.swift
    W8TrackrWidget/Views/MediumWidgetView.swift
    W8TrackrWidget/Views/EmptyStateView.swift
  </files>
  <action>
Create the small and medium widget view implementations.

1. Create `W8TrackrWidget/Views/` directory

2. Create `EmptyStateView.swift` (shared empty state for all sizes):
```swift
import SwiftUI
import WidgetKit

/// Empty state view when no weight entries exist
struct EmptyStateView: View {
    @Environment(\.widgetFamily) var family

    var body: some View {
        VStack(spacing: family == .systemSmall ? 4 : 8) {
            Image(systemName: "scalemass")
                .font(family == .systemSmall ? .title2 : .largeTitle)
                .foregroundStyle(.secondary)

            Text("Add your first weigh-in")
                .font(family == .systemSmall ? .caption2 : .caption)
                .foregroundStyle(.secondary)
                .multilineTextAlignment(.center)
        }
        .widgetURL(URL(string: "w8trackr://"))
    }
}

/// View when no goal is set (for medium widget progress)
struct NoGoalView: View {
    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: "target")
                .font(.title)
                .foregroundStyle(.secondary)

            Text("Set a goal to track progress")
                .font(.caption)
                .foregroundStyle(.secondary)
                .multilineTextAlignment(.center)
        }
        .widgetURL(URL(string: "w8trackr://"))
    }
}
```

3. Create `SmallWidgetView.swift`:
```swift
import SwiftUI
import WidgetKit

/// Small widget: Current weight + trend arrow
/// Weight is hero element - large and bold
struct SmallWidgetView: View {
    let entry: WeightWidgetEntry

    var body: some View {
        if entry.currentWeight == nil {
            EmptyStateView()
        } else {
            contentView
                .widgetURL(URL(string: "w8trackr://"))
        }
    }

    private var contentView: some View {
        VStack(alignment: .leading, spacing: 4) {
            // App identifier
            HStack(spacing: 4) {
                Image(systemName: "scalemass.fill")
                    .font(.caption2)
                Text("W8Trackr")
                    .font(.caption2)
                    .fontWeight(.medium)
            }
            .foregroundStyle(.secondary)

            Spacer()

            // Weight - hero element
            HStack(alignment: .firstTextBaseline, spacing: 2) {
                Text("\(entry.currentWeight ?? 0)")
                    .font(.system(size: 44, weight: .bold, design: .rounded))
                    .minimumScaleFactor(0.6)

                Text(entry.weightUnit)
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }

            // Trend indicator (neutral colors per CONTEXT.md)
            HStack(spacing: 4) {
                Image(systemName: entry.trend.systemImage)
                    .font(.caption)

                Text(trendText)
                    .font(.caption2)
            }
            .foregroundStyle(trendColor)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .leading)
    }

    private var trendText: String {
        switch entry.trend {
        case .up: return "Trending up"
        case .down: return "Trending down"
        case .neutral: return "Holding steady"
        case .unknown: return "Not enough data"
        }
    }

    /// Neutral colors per CONTEXT.md - no red/green judgment
    private var trendColor: Color {
        switch entry.trend {
        case .up, .down: return .primary
        case .neutral, .unknown: return .secondary
        }
    }
}
```

4. Create `MediumWidgetView.swift`:
```swift
import SwiftUI
import WidgetKit

/// Medium widget: Progress toward goal weight
/// Shows current weight, goal, and progress visualization
struct MediumWidgetView: View {
    let entry: WeightWidgetEntry

    var body: some View {
        if entry.currentWeight == nil {
            EmptyStateView()
        } else if entry.goalWeight == nil {
            NoGoalView()
        } else {
            contentView
                .widgetURL(URL(string: "w8trackr://"))
        }
    }

    private var contentView: some View {
        HStack(spacing: 16) {
            // Left side: Current weight (hero)
            VStack(alignment: .leading, spacing: 4) {
                HStack(spacing: 4) {
                    Image(systemName: "scalemass.fill")
                        .font(.caption2)
                    Text("W8Trackr")
                        .font(.caption2)
                        .fontWeight(.medium)
                }
                .foregroundStyle(.secondary)

                Spacer()

                HStack(alignment: .firstTextBaseline, spacing: 2) {
                    Text("\(entry.currentWeight ?? 0)")
                        .font(.system(size: 44, weight: .bold, design: .rounded))
                        .minimumScaleFactor(0.6)

                    Text(entry.weightUnit)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }

                // Trend
                HStack(spacing: 4) {
                    Image(systemName: entry.trend.systemImage)
                        .font(.caption)
                    Text(trendText)
                        .font(.caption2)
                }
                .foregroundStyle(entry.trend == .unknown ? .secondary : .primary)
            }

            Divider()

            // Right side: Progress
            VStack(alignment: .trailing, spacing: 8) {
                Text("Goal: \(entry.goalWeight ?? 0) \(entry.weightUnit)")
                    .font(.caption)
                    .foregroundStyle(.secondary)

                Spacer()

                // Progress percentage
                if let progress = entry.progressPercent {
                    Text(progressText(progress))
                        .font(.system(size: 28, weight: .semibold, design: .rounded))

                    // Remaining
                    Text(remainingText)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                } else {
                    Text("--")
                        .font(.title)
                        .foregroundStyle(.secondary)
                }

                // Simple progress bar
                ProgressBarView(progress: entry.progressPercent ?? 0)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    private var trendText: String {
        switch entry.trend {
        case .up: return "Up"
        case .down: return "Down"
        case .neutral: return "Steady"
        case .unknown: return "â€”"
        }
    }

    private func progressText(_ progress: Double) -> String {
        let percent = Int(min(max(progress, 0), 1) * 100)
        return "\(percent)%"
    }

    private var remainingText: String {
        guard let current = entry.currentWeight,
              let goal = entry.goalWeight else {
            return ""
        }

        let diff = abs(current - goal)
        return "\(diff) \(entry.weightUnit) to go"
    }
}

/// Simple progress bar for medium widget
struct ProgressBarView: View {
    let progress: Double

    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                // Background
                RoundedRectangle(cornerRadius: 4)
                    .fill(.secondary.opacity(0.3))

                // Progress fill
                RoundedRectangle(cornerRadius: 4)
                    .fill(.blue)
                    .frame(width: geometry.size.width * min(max(progress, 0), 1))
            }
        }
        .frame(height: 6)
    }
}
```

IMPORTANT:
- Weight is the hero element - large and bold per CONTEXT.md
- Use neutral colors for trend (no red/green) per CONTEXT.md
- Use widgetURL for tap-to-open (required for small widgets)
- Handle empty state gracefully with helpful prompts
  </action>
  <verify>
1. Build succeeds: `xcodebuild -project W8Trackr.xcodeproj -scheme W8TrackrWidget -sdk iphonesimulator build`
2. No SwiftLint errors: `swiftlint lint W8TrackrWidget/`
  </verify>
  <done>
Small widget shows current weight with trend arrow. Medium widget shows progress percentage with goal. Both handle empty states gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Large Widget with Sparkline Chart</name>
  <files>
    W8TrackrWidget/Views/LargeWidgetView.swift
  </files>
  <action>
Create the large widget with sparkline chart using Swift Charts.

Create `LargeWidgetView.swift`:
```swift
import SwiftUI
import WidgetKit
import Charts

/// Large widget: Sparkline chart of last 7 days
/// Shows weight trend visualization with filled area chart
struct LargeWidgetView: View {
    let entry: WeightWidgetEntry

    var body: some View {
        if entry.currentWeight == nil {
            EmptyStateView()
        } else {
            contentView
                .widgetURL(URL(string: "w8trackr://"))
        }
    }

    private var contentView: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Header
            HStack {
                HStack(spacing: 4) {
                    Image(systemName: "scalemass.fill")
                        .font(.caption)
                    Text("W8Trackr")
                        .font(.caption)
                        .fontWeight(.medium)
                }
                .foregroundStyle(.secondary)

                Spacer()

                // Current weight (smaller than small widget, since chart is hero)
                HStack(alignment: .firstTextBaseline, spacing: 2) {
                    Text("\(entry.currentWeight ?? 0)")
                        .font(.system(size: 28, weight: .bold, design: .rounded))

                    Text(entry.weightUnit)
                        .font(.caption)
                        .foregroundStyle(.secondary)

                    // Trend arrow
                    Image(systemName: entry.trend.systemImage)
                        .font(.caption)
                        .foregroundStyle(entry.trend == .unknown ? .secondary : .primary)
                }
            }

            // Chart - hero element for large widget
            if entry.chartData.count >= 2 {
                SparklineChartView(data: entry.chartData, unit: entry.weightUnit)
                    .frame(maxHeight: .infinity)
            } else {
                // Not enough data for chart
                VStack(spacing: 8) {
                    Spacer()
                    Image(systemName: "chart.line.uptrend.xyaxis")
                        .font(.largeTitle)
                        .foregroundStyle(.secondary)
                    Text("Add more weigh-ins to see your trend")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                        .multilineTextAlignment(.center)
                    Spacer()
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            }

            // Footer: 7-day summary
            if entry.chartData.count >= 2 {
                HStack {
                    Text("Last 7 days")
                        .font(.caption2)
                        .foregroundStyle(.secondary)

                    Spacer()

                    if let change = weeklyChange {
                        Text(change)
                            .font(.caption2)
                            .foregroundStyle(.secondary)
                    }
                }
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    private var weeklyChange: String? {
        guard entry.chartData.count >= 2,
              let first = entry.chartData.first,
              let last = entry.chartData.last else {
            return nil
        }

        let diff = last.weight - first.weight
        let sign = diff >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", diff)) \(entry.weightUnit)"
    }
}

/// Sparkline chart with filled area gradient (like Apple Fitness widgets)
struct SparklineChartView: View {
    let data: [WeightWidgetEntry.ChartDataPoint]
    let unit: String

    var body: some View {
        Chart(data) { point in
            // Area fill with gradient (per CONTEXT.md: filled area chart like Apple Fitness)
            AreaMark(
                x: .value("Date", point.date),
                y: .value("Weight", point.weight)
            )
            .foregroundStyle(
                .linearGradient(
                    colors: [.blue.opacity(0.4), .blue.opacity(0.1), .clear],
                    startPoint: .top,
                    endPoint: .bottom
                )
            )
            .interpolationMethod(.catmullRom)

            // Line on top
            LineMark(
                x: .value("Date", point.date),
                y: .value("Weight", point.weight)
            )
            .foregroundStyle(.blue)
            .lineStyle(StrokeStyle(lineWidth: 2))
            .interpolationMethod(.catmullRom)

            // Point markers
            PointMark(
                x: .value("Date", point.date),
                y: .value("Weight", point.weight)
            )
            .foregroundStyle(.blue)
            .symbolSize(20)
        }
        .chartXAxis(.hidden)
        .chartYAxis {
            AxisMarks(position: .trailing) { value in
                if let weight = value.as(Double.self) {
                    AxisValueLabel {
                        Text("\(Int(weight))")
                            .font(.caption2)
                            .foregroundStyle(.secondary)
                    }
                }
            }
        }
        .chartYScale(domain: yAxisDomain)
    }

    /// Calculate Y axis domain with padding
    private var yAxisDomain: ClosedRange<Double> {
        let weights = data.map(\.weight)
        let minWeight = weights.min() ?? 0
        let maxWeight = weights.max() ?? 100
        let padding = (maxWeight - minWeight) * 0.1
        return (minWeight - padding)...(maxWeight + padding)
    }
}
```

IMPORTANT:
- Use filled area chart with gradient (per CONTEXT.md: like Apple Fitness widgets)
- Use catmullRom interpolation for smooth curves
- Chart is the hero element for large widget
- Show helpful message when not enough data for chart
- Y-axis shows weight values for context
  </action>
  <verify>
1. Build succeeds: `xcodebuild -project W8Trackr.xcodeproj -scheme W8TrackrWidget -sdk iphonesimulator build`
2. No SwiftLint errors: `swiftlint lint W8TrackrWidget/`
  </verify>
  <done>
Large widget displays sparkline chart with filled area gradient showing last 7 days of weight data.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate Widget Refresh and Update Entry View</name>
  <files>
    W8TrackrWidget/W8TrackrWidget.swift
    W8Trackr/Views/AddWeightSheet.swift
    W8Trackr/Views/EditWeightSheet.swift
    W8Trackr/Views/SettingsView.swift
  </files>
  <action>
1. Update `W8TrackrWidget.swift` to use the new views:
```swift
import WidgetKit
import SwiftUI

@main
struct W8TrackrWidgetBundle: WidgetBundle {
    var body: some Widget {
        WeightWidget()
    }
}

struct WeightWidget: Widget {
    let kind: String = "WeightWidget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: WeightWidgetProvider()) { entry in
            WeightWidgetEntryView(entry: entry)
                .containerBackground(.fill.tertiary, for: .widget)
        }
        .configurationDisplayName("Weight Tracker")
        .description("See your current weight and progress at a glance.")
        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])
    }
}

struct WeightWidgetEntryView: View {
    @Environment(\.widgetFamily) var family
    let entry: WeightWidgetEntry

    var body: some View {
        switch family {
        case .systemSmall:
            SmallWidgetView(entry: entry)
        case .systemMedium:
            MediumWidgetView(entry: entry)
        case .systemLarge:
            LargeWidgetView(entry: entry)
        default:
            SmallWidgetView(entry: entry)
        }
    }
}
```

2. Add widget refresh calls to `AddWeightSheet.swift`:
   - After successful save (when entry is added to context)
   - Add `import WidgetKit` at top
   - Call `WidgetCenter.shared.reloadTimelines(ofKind: "WeightWidget")` after save

3. Add widget refresh calls to `EditWeightSheet.swift`:
   - After save (update) and after delete
   - Add `import WidgetKit` at top
   - Call `WidgetCenter.shared.reloadTimelines(ofKind: "WeightWidget")` after modifications

4. Add widget refresh calls to `SettingsView.swift`:
   - After goal weight changes
   - After weight unit changes
   - Add `import WidgetKit` at top
   - Call `WidgetCenter.shared.reloadTimelines(ofKind: "WeightWidget")` after preference changes

IMPORTANT:
- Widget kind string must match exactly: "WeightWidget"
- Call reloadTimelines AFTER the data change is committed (after modelContext.insert or save)
- Widgets will refresh immediately when main app data changes
- This is NOT subject to the 40-70/day refresh budget (app-triggered reloads are unlimited)
  </action>
  <verify>
1. Build both targets: `xcodebuild -project W8Trackr.xcodeproj -scheme W8Trackr -sdk iphonesimulator build`
2. Verify WidgetKit import in modified files
3. Grep for reloadTimelines calls: should appear in AddWeightSheet, EditWeightSheet, SettingsView
  </verify>
  <done>
Entry view routes to size-specific views. Main app triggers widget refresh on all data modifications (add, edit, delete) and preference changes (goal, unit).
  </done>
</task>

</tasks>

<verification>
1. All three widget sizes build and display correctly
2. Empty states show helpful prompts
3. Tapping any widget opens the app
4. Widgets refresh when user modifies data in main app
5. SwiftLint passes for all files
</verification>

<success_criteria>
- Small widget displays current weight with trend arrow (WDGT-01)
- Medium widget displays progress percentage toward goal (WDGT-02)
- Large widget displays sparkline chart of last 7 days (WDGT-03)
- Main app calls reloadTimelines after data changes (WDGT-04)
- All widgets have widgetURL for tap-to-open (WDGT-05)
</success_criteria>

<output>
After completion, create `.planning/phases/22-widgets/22-02-SUMMARY.md`
</output>
