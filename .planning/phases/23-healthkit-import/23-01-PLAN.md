---
phase: 23-healthkit-import
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - W8Trackr/W8Trackr.entitlements
  - W8Trackr/Managers/HealthSyncManager.swift
autonomous: true

must_haves:
  truths:
    - "App can request HealthKit read permission for weight data"
    - "App can fetch all weight samples from HealthKit using anchored query"
    - "App can convert HKQuantitySample to WeightEntry with source attribution"
    - "Anchor is persisted for incremental sync across app launches"
  artifacts:
    - path: "W8Trackr/W8Trackr.entitlements"
      provides: "Background delivery entitlement for HealthKit"
      contains: "com.apple.developer.healthkit.background-delivery"
    - path: "W8Trackr/Managers/HealthSyncManager.swift"
      provides: "Import operations using HKAnchoredObjectQueryDescriptor"
      exports: ["importWeightFromHealth", "saveAnchor", "loadAnchor"]
  key_links:
    - from: "HealthSyncManager.importWeightFromHealth"
      to: "HKAnchoredObjectQueryDescriptor"
      via: "descriptor.result(for:) async call"
      pattern: "HKAnchoredObjectQueryDescriptor.*result.*for"
    - from: "HealthSyncManager"
      to: "WeightEntry"
      via: "createEntryFromSample conversion"
      pattern: "createEntryFromSample.*HKQuantitySample"
---

<objective>
Add HealthKit import capability with anchored queries for incremental sync

Purpose: Enable W8Trackr to import weight data from Apple Health (HKIT-01, HKIT-02, HKIT-03, HKIT-04)
Output: HealthSyncManager extended with import operations, background-delivery entitlement added
</objective>

<execution_context>
@~/.claude/agents/gsd-executor.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-healthkit-import/23-RESEARCH.md
@W8Trackr/Managers/HealthSyncManager.swift
@W8Trackr/Managers/HealthStoreProtocol.swift
@W8Trackr/Models/WeightEntry.swift
@W8Trackr/W8Trackr.entitlements
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add background-delivery entitlement</name>
  <files>W8Trackr/W8Trackr.entitlements</files>
  <action>
Add the HealthKit background delivery entitlement required for HKIT-05 (background sync).

Add this key to the entitlements plist after the existing `com.apple.developer.healthkit` key:
```xml
<key>com.apple.developer.healthkit.background-delivery</key>
<true/>
```

This enables HKObserverQuery to receive updates when the app is suspended. Without this entitlement, observer queries only work in foreground.
  </action>
  <verify>
Read the entitlements file and confirm both `com.apple.developer.healthkit` and `com.apple.developer.healthkit.background-delivery` are present with `<true/>` values.
  </verify>
  <done>
Entitlements file contains both HealthKit entitlements (base + background-delivery)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add import operations to HealthSyncManager</name>
  <files>W8Trackr/Managers/HealthSyncManager.swift</files>
  <action>
Extend HealthSyncManager with import operations for reading weight data from HealthKit.

**Add anchor persistence methods:**

```swift
// MARK: - Anchor Persistence

/// Saves the HKQueryAnchor for incremental sync across app launches.
private func saveAnchor(_ anchor: HKQueryAnchor?) {
    guard let anchor = anchor else { return }
    do {
        let data = try NSKeyedArchiver.archivedData(
            withRootObject: anchor,
            requiringSecureCoding: true
        )
        healthSyncAnchor = data
    } catch {
        print("Failed to archive anchor: \(error)")
    }
}

/// Loads the persisted HKQueryAnchor for incremental sync.
private func loadAnchor() -> HKQueryAnchor? {
    guard let data = healthSyncAnchor else { return nil }
    do {
        return try NSKeyedUnarchiver.unarchivedObject(
            ofClass: HKQueryAnchor.self,
            from: data
        )
    } catch {
        print("Failed to unarchive anchor: \(error)")
        return nil
    }
}
```

**Add import operations:**

```swift
// MARK: - Import Operations

/// Imports weight entries from HealthKit using an anchored query.
///
/// Uses HKAnchoredObjectQueryDescriptor for incremental sync:
/// - First call (nil anchor): Fetches all historical weight data
/// - Subsequent calls: Fetches only changes since last sync
///
/// Creates WeightEntry for each imported sample with source attribution.
/// Skips samples that were originally created by W8Trackr (by checking source bundle ID).
///
/// - Parameter modelContext: The SwiftData context to insert entries into
/// - Returns: Number of new entries imported
/// - Throws: HealthKit query errors
@discardableResult
func importWeightFromHealth(modelContext: ModelContext) async throws -> Int {
    guard Self.isHealthDataAvailable,
          let weightType = weightType else {
        return 0
    }

    syncStatus = .syncing

    do {
        let descriptor = HKAnchoredObjectQueryDescriptor(
            predicates: [.quantitySample(type: weightType)],
            anchor: loadAnchor()
        )

        let result = try await descriptor.result(for: healthStore as! HKHealthStore)

        // Save anchor for next incremental sync
        saveAnchor(result.newAnchor)

        var importedCount = 0

        // Process added samples
        for sample in result.addedSamples {
            guard let quantitySample = sample as? HKQuantitySample else { continue }

            // Skip samples created by W8Trackr (avoid duplicates)
            if quantitySample.sourceRevision.source.bundleIdentifier == Bundle.main.bundleIdentifier {
                continue
            }

            // Skip if we already have this entry (by healthKitUUID)
            let uuidString = quantitySample.uuid.uuidString
            let existingDescriptor = FetchDescriptor<WeightEntry>(
                predicate: #Predicate { $0.healthKitUUID == uuidString }
            )
            let existingEntries = try modelContext.fetch(existingDescriptor)
            guard existingEntries.isEmpty else { continue }

            // Create WeightEntry from sample
            let entry = createEntryFromSample(quantitySample)
            modelContext.insert(entry)
            importedCount += 1
        }

        // Handle deleted samples - remove imported entries if source sample was deleted
        for sample in result.deletedObjects {
            guard let deletedSample = sample as? HKQuantitySample else { continue }
            let uuidString = deletedSample.uuid.uuidString
            let deleteDescriptor = FetchDescriptor<WeightEntry>(
                predicate: #Predicate { $0.healthKitUUID == uuidString }
            )
            let entriesToDelete = try modelContext.fetch(deleteDescriptor)
            for entry in entriesToDelete {
                // Only delete imported entries (not W8Trackr-created ones)
                if entry.isImported {
                    modelContext.delete(entry)
                }
            }
        }

        if importedCount > 0 || !result.deletedObjects.isEmpty {
            try modelContext.save()
        }

        syncStatus = .success
        lastHealthSyncDate = Date()

        return importedCount
    } catch {
        syncStatus = .failed(error.localizedDescription)
        throw error
    }
}

/// Creates a WeightEntry from an HKQuantitySample.
///
/// Converts the sample to the app's internal format:
/// - Extracts weight in kg from the sample quantity
/// - Converts to lb (app's storage unit)
/// - Sets source to the originating app/device name
/// - Stores healthKitUUID for duplicate detection
/// - Marks pendingHealthSync as false (already in Health)
private func createEntryFromSample(_ sample: HKQuantitySample) -> WeightEntry {
    let weightInKg = sample.quantity.doubleValue(for: .gramUnit(with: .kilo))
    let weightInLb = weightInKg * WeightUnit.kgToLb

    let entry = WeightEntry(
        weight: weightInLb,
        unit: .lb,
        date: sample.startDate
    )

    // Set source from HealthKit sample (e.g., "Withings Scale", "Fitness app")
    entry.source = sample.sourceRevision.source.name
    entry.healthKitUUID = sample.uuid.uuidString
    entry.pendingHealthSync = false  // Already in Health, no need to sync back

    return entry
}
```

**Important implementation notes:**
- Use `HKAnchoredObjectQueryDescriptor` (modern async API, not the legacy callback version)
- The `descriptor.result(for:)` call requires casting `healthStore` to `HKHealthStore` because the protocol doesn't expose this method
- Source filtering by bundle ID prevents re-importing entries that W8Trackr originally created and exported to Health
- The WeightEntry is stored in lb (app's internal format) regardless of what unit the sample used
  </action>
  <verify>
Build the project:
```bash
xcodebuild -project W8Trackr.xcodeproj -scheme W8Trackr -configuration Debug -sdk iphonesimulator build 2>&1 | tail -20
```
Confirm no build errors related to HealthSyncManager or import operations.
  </verify>
  <done>
HealthSyncManager has:
- `importWeightFromHealth(modelContext:)` async method for bulk/incremental import
- `createEntryFromSample(_:)` for HKQuantitySample to WeightEntry conversion
- `saveAnchor(_:)` and `loadAnchor()` for anchor persistence
- Source filtering to skip W8Trackr-created samples
- Duplicate detection by healthKitUUID
  </done>
</task>

</tasks>

<verification>
1. Build succeeds with no errors
2. Entitlements file has both HealthKit entitlements
3. HealthSyncManager compiles with new import methods
4. No SwiftLint violations introduced
</verification>

<success_criteria>
- Background-delivery entitlement added to W8Trackr.entitlements
- HealthSyncManager extended with `importWeightFromHealth(modelContext:)` method
- Anchor persistence implemented with NSKeyedArchiver/Unarchiver
- Source attribution sets WeightEntry.source from HKSource.name
- Duplicate detection uses healthKitUUID to avoid re-importing
</success_criteria>

<output>
After completion, create `.planning/phases/23-healthkit-import/23-01-SUMMARY.md`
</output>
