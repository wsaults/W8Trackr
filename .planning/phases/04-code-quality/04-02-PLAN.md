---
phase: 04-code-quality
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - W8Trackr/Managers/NotificationManager.swift
  - W8Trackr/Managers/HealthKitManager.swift
  - W8Trackr/Managers/CloudKitSyncManager.swift
autonomous: true

must_haves:
  truths:
    - "No DispatchQueue.main.async remains in Manager files"
    - "All managers use @Observable + @MainActor pattern"
    - "Notification permission uses async/await"
    - "CloudKit status check uses async/await"
  artifacts:
    - path: "W8Trackr/Managers/NotificationManager.swift"
      provides: "@MainActor notification manager"
      contains: "@MainActor"
    - path: "W8Trackr/Managers/CloudKitSyncManager.swift"
      provides: "@MainActor sync manager with network monitor"
      contains: "@MainActor"
    - path: "W8Trackr/Managers/HealthKitManager.swift"
      provides: "@MainActor HealthKit manager"
      contains: "@MainActor"
  key_links:
    - from: "W8Trackr/Managers/CloudKitSyncManager.swift"
      to: "NWPathMonitor"
      via: "MainActor.run in monitor callback"
      pattern: "MainActor\\.run"
---

<objective>
Migrate Manager classes from GCD to Swift concurrency

Purpose: Eliminate DispatchQueue patterns in Manager classes to complete QUAL-01 requirement
Output: All Manager files use @Observable + @MainActor with async/await patterns
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-code-quality/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate NotificationManager to @MainActor</name>
  <files>
    W8Trackr/Managers/NotificationManager.swift
  </files>
  <action>
    Convert NotificationManager from ObservableObject + GCD to @Observable + @MainActor:

    Changes needed:

    1. Add @MainActor and @Observable annotations:
       Before: `class NotificationManager: ObservableObject`
       After: `@Observable @MainActor final class NotificationManager`

    2. Remove @Published from properties (not needed with @Observable):
       Before: `@Published var isReminderEnabled = false`
       After: `var isReminderEnabled = false`

    3. Line 49 - checkNotificationStatus completion handler:
       Before:
       ```swift
       UNUserNotificationCenter.current().getNotificationSettings { settings in
           DispatchQueue.main.async {
               self.isReminderEnabled = settings.authorizationStatus == .authorized
           }
       }
       ```
       After:
       ```swift
       Task {
           let settings = await UNUserNotificationCenter.current().notificationSettings()
           isReminderEnabled = settings.authorizationStatus == .authorized
       }
       ```

    4. Line 64 - requestNotificationPermission:
       Convert completion handler pattern to async:
       Before:
       ```swift
       func requestNotificationPermission(completion: @escaping (Bool) -> Void) {
           UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound]) { granted, _ in
               DispatchQueue.main.async {
                   self.isReminderEnabled = granted
                   completion(granted)
               }
           }
       }
       ```
       After:
       ```swift
       func requestNotificationPermission() async -> Bool {
           do {
               let granted = try await UNUserNotificationCenter.current()
                   .requestAuthorization(options: [.alert, .sound])
               isReminderEnabled = granted
               return granted
           } catch {
               return false
           }
       }
       ```

    5. Line 163 - suggestedTime update:
       Before: `DispatchQueue.main.async { self.suggestedTime = ... }`
       After: Direct assignment (already on @MainActor)

    6. Update any call sites that use the completion handler version to use async/await

    Note: @MainActor makes DispatchQueue.main.async unnecessary - direct property assignment is safe.
  </action>
  <verify>
    Run: `grep -r "DispatchQueue" W8Trackr/Managers/NotificationManager.swift` returns no results
    Run: `grep "@MainActor" W8Trackr/Managers/NotificationManager.swift` returns results
    Build succeeds
  </verify>
  <done>NotificationManager uses @Observable + @MainActor with async/await APIs</done>
</task>

<task type="auto">
  <name>Task 2: Migrate HealthKitManager to @MainActor</name>
  <files>
    W8Trackr/Managers/HealthKitManager.swift
  </files>
  <action>
    Convert HealthKitManager from ObservableObject + GCD to @Observable + @MainActor:

    Note from RESEARCH: Consider consolidating with HealthSyncManager. For now, migrate existing HealthKitManager. Consolidation is out of scope for QUAL-01.

    Changes needed:

    1. Add @MainActor and @Observable annotations:
       Before: `class HealthKitManager: ObservableObject`
       After: `@Observable @MainActor final class HealthKitManager`

    2. Remove @Published from properties:
       `@Published var isAuthorized = false` -> `var isAuthorized = false`

    3. Line 59 - init status check:
       Before: `DispatchQueue.main.async { self.isAuthorized = ... }`
       After: Direct assignment (already on @MainActor)

    4. Line 84 - requestAuthorization completion:
       Before:
       ```swift
       healthStore.requestAuthorization(toShare: ..., read: ...) { success, _ in
           DispatchQueue.main.async {
               self.isAuthorized = success
               completion(success)
           }
       }
       ```
       After: Convert to async/await pattern:
       ```swift
       func requestAuthorization() async -> Bool {
           do {
               try await healthStore.requestAuthorization(toShare: ..., read: ...)
               isAuthorized = true
               return true
           } catch {
               isAuthorized = false
               return false
           }
       }
       ```

    5. Line 106 - authorizationStatus update:
       Before: `DispatchQueue.main.async { self.isAuthorized = ... }`
       After: Direct assignment

    6. Line 116 - saveWeight completion:
       Convert to async:
       ```swift
       func saveWeight(_ weight: Double, date: Date) async throws {
           let sample = HKQuantitySample(...)
           try await healthStore.save(sample)
       }
       ```

    7. Line 141 - fetchBodyFatPercentage completion:
       Convert to async pattern using HKSampleQueryDescriptor or continuation

    8. Update call sites to use async versions

    If HealthKitManager is not actively used (HealthSyncManager is the main manager), mark methods as deprecated or minimize changes to just GCD removal.
  </action>
  <verify>
    Run: `grep -r "DispatchQueue" W8Trackr/Managers/HealthKitManager.swift` returns no results
    Run: `grep "@MainActor" W8Trackr/Managers/HealthKitManager.swift` returns results
    Build succeeds
  </verify>
  <done>HealthKitManager uses @Observable + @MainActor with no GCD patterns</done>
</task>

<task type="auto">
  <name>Task 3: Migrate CloudKitSyncManager to @MainActor</name>
  <files>
    W8Trackr/Managers/CloudKitSyncManager.swift
  </files>
  <action>
    Convert CloudKitSyncManager from ObservableObject + GCD to @Observable + @MainActor:

    This is the most complex migration due to NWPathMonitor and Combine usage.

    Changes needed:

    1. Add @MainActor and @Observable annotations:
       Before: `class CloudKitSyncManager: ObservableObject`
       After: `@Observable @MainActor final class CloudKitSyncManager`

    2. Remove @Published from properties

    3. Line 32 - Keep monitorQueue:
       `private let monitorQueue = DispatchQueue(label: "com.w8trackr.networkMonitor")`
       NWPathMonitor requires its own queue - this is acceptable. Do NOT remove.

    4. Line 46 - Monitor path update handler:
       Before:
       ```swift
       monitor.pathUpdateHandler = { [weak self] path in
           DispatchQueue.main.async {
               self?.isNetworkAvailable = path.status == .satisfied
           }
       }
       ```
       After:
       ```swift
       monitor.pathUpdateHandler = { [weak self] path in
           Task { @MainActor in
               self?.isNetworkAvailable = path.status == .satisfied
           }
       }
       ```

    5. Lines 61, 69 - Combine .receive(on: DispatchQueue.main):
       Before: `.receive(on: DispatchQueue.main).sink { ... }`
       After: `.sink { value in Task { @MainActor in self.property = value } }`

       Or convert entire subscription to async stream if simpler.

    6. Line 94 - asyncAfter for sync retry:
       Before: `DispatchQueue.main.asyncAfter(deadline: .now() + 2) { ... }`
       After: `Task { try? await Task.sleep(for: .seconds(2)); ... }`

    7. Line 111 - accountStatus completion:
       Convert CKContainer.accountStatus to async:
       Before:
       ```swift
       CKContainer.default().accountStatus { status, _ in
           DispatchQueue.main.async { ... }
       }
       ```
       After:
       ```swift
       Task {
           let status = try? await CKContainer.default().accountStatus()
           // update property directly
       }
       ```

    8. Line 148 - asyncAfter for status reset:
       Before: `DispatchQueue.main.asyncAfter(deadline: .now() + 1) { ... }`
       After: `Task { try? await Task.sleep(for: .seconds(1)); ... }`

    Key insight: Keep the monitorQueue for NWPathMonitor but use `Task { @MainActor in }` for property updates from the callback.
  </action>
  <verify>
    Run: `grep "DispatchQueue.main" W8Trackr/Managers/CloudKitSyncManager.swift` returns no results
    Run: `grep "\.receive(on: DispatchQueue" W8Trackr/Managers/CloudKitSyncManager.swift` returns no results
    Only remaining DispatchQueue should be monitorQueue definition
    Run: `grep "@MainActor" W8Trackr/Managers/CloudKitSyncManager.swift` returns results
    Build succeeds
  </verify>
  <done>CloudKitSyncManager uses @Observable + @MainActor, only monitorQueue remains (required by NWPathMonitor)</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `grep "DispatchQueue.main" W8Trackr/Managers/` returns no results
2. `grep "\.receive(on: DispatchQueue" W8Trackr/Managers/` returns no results
3. Only acceptable DispatchQueue is monitorQueue in CloudKitSyncManager
4. All three managers have @MainActor annotation
5. Build succeeds
6. Run SwiftLint: `swiftlint lint` passes with zero warnings
</verification>

<success_criteria>
- Zero DispatchQueue.main.async/asyncAfter in Manager files
- Zero .receive(on: DispatchQueue.main) in Combine pipelines
- All managers annotated with @Observable + @MainActor
- Only acceptable DispatchQueue: monitorQueue for NWPathMonitor
- Build passes
- SwiftLint passes with zero warnings (phase success criteria #4)
</success_criteria>

<output>
After completion, create `.planning/phases/04-code-quality/04-02-SUMMARY.md`
</output>
