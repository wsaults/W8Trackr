---
phase: 29-chart-scroll-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - W8Trackr/Views/WeightTrendChartView.swift
autonomous: false

must_haves:
  truths:
    - "Chart scrolls horizontally through all weight data without jank at 60fps"
    - "ALL weight entries are always in the chart regardless of DateRange selection"
    - "DateRange picker controls the visible window width, not which data is loaded"
    - "Y-axis remains stable during horizontal scroll (no jumping)"
    - "Tap-to-select still works during and after scrolling"
    - "Vertical page scroll is not blocked by chart horizontal scroll"
    - "Changing DateRange resets scroll position to show most recent data"
  artifacts:
    - path: "W8Trackr/Views/WeightTrendChartView.swift"
      provides: "Smooth scrollable weight trend chart"
      contains: "chartScrollableAxes(.horizontal)"
  key_links:
    - from: "recomputeChartData()"
      to: "cachedData"
      via: "ALL entries (no range filtering on data points)"
      pattern: "let sortedEntries = entries\\.sorted"
    - from: "DateRange.days"
      to: "chartXVisibleDomain"
      via: "visibleDomainSeconds computed property"
      pattern: "chartXVisibleDomain"
    - from: "chartScrollPosition"
      to: "initialX (non-binding)"
      via: "initialScrollDate computed property"
      pattern: "chartScrollPosition\\(initialX:"
    - from: ".id(selectedRange)"
      to: "chart re-creation"
      via: "forces initialX to re-apply on range change"
      pattern: "\\.id\\(selectedRange\\)"
---

<objective>
Enable smooth horizontal scrolling on the weight trend chart by separating the data layer (always ALL entries) from the scroll layer (non-reactive visible window controlled by DateRange).

Purpose: Four prior attempts failed because data filtering was coupled to scroll state, or the reactive scroll binding caused per-frame body re-evaluation. This plan fixes ALL layers simultaneously: (1) non-reactive `initialX`, (2) ALL data loaded, (3) stable Y-axis, (4) `visibleDomain` from DateRange, (5) `.id(selectedRange)` for range-change reset, (6) no `.animation()` on chart.

Output: A single modified `WeightTrendChartView.swift` with smooth 60fps horizontal scrolling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-chart-scroll-performance/29-RESEARCH.md
@W8Trackr/Views/WeightTrendChartView.swift
@W8Trackr/Views/ChartSectionView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Decouple data layer from scroll layer and add horizontal scrolling</name>
  <files>W8Trackr/Views/WeightTrendChartView.swift</files>
  <action>
Modify `WeightTrendChartView.swift` with these specific changes. Read the file first to understand the current structure.

**1. Make `ChartEntry` conform to `Equatable`:**
Add `Equatable` conformance to the `ChartEntry` struct. It already has all value-type properties (`Date`, `Double`, `Bool`), so synthesized conformance works:
```swift
private struct ChartEntry: Identifiable, Equatable {
```

**2. Make `PreparedChartData` conform to `Equatable`:**
Add `Equatable` conformance to `PreparedChartData`. Since `ChartEntry` is now `Equatable` and `ClosedRange<Date>` is already `Equatable`, synthesized conformance works:
```swift
private struct PreparedChartData: Equatable {
```

**3. Remove ALL range filtering from `recomputeChartData()`:**
The function currently filters entries to `selectedRange.days` (lines 53-61) and filters trend to cutoff (lines 68-73). Replace the entire function body so it uses ALL entries:

- Remove the `let rangeEntries` / `if let days = selectedRange.days` block at the top (lines 53-61)
- Replace `let sortedRangeEntries = rangeEntries.sorted` with `let sortedEntries = entries.sorted { $0.date < $1.date }`
- Remove the smoothing cutoff: delete the `cutoffDate`, `rangeTrend` variables (lines 68-73). Instead, map ALL `allTrend` points directly to `smoothed` entries
- Change `let points = sortedRangeEntries.map` to `let points = sortedEntries.map`
- Change the date domain: use `sortedEntries.first?.date` (not `sortedRangeEntries.first?.date`) as the start. The end should be `predictionEnd` (14 days after the last entry date from ALL entries)

Here is the complete replacement for `recomputeChartData()`:
```swift
private func recomputeChartData() {
    let sortedEntries = entries.sorted { $0.date < $1.date }

    // Compute EMA from ALL entries
    let allTrend = TrendCalculator.exponentialMovingAverage(entries: entries, span: 10)

    var smoothed: [ChartEntry] = []
    if showSmoothing {
        // ALL trend points — no range filtering
        smoothed = allTrend.map { point in
            ChartEntry(
                date: point.date,
                weight: point.smoothedWeight(in: weightUnit),
                isPrediction: false,
                showPoint: false,
                isIndividualEntry: false,
                isSmoothed: true
            )
        }
    }

    // ALL data points — no range filtering
    let points = sortedEntries.map { entry in
        ChartEntry(
            date: entry.date,
            weight: entry.weightValue(in: weightUnit),
            isPrediction: false,
            showPoint: true,
            isIndividualEntry: true,
            isSmoothed: false
        )
    }

    let predictions = makePredictionPoints(trend: allTrend)

    // Date domain spans ALL data + predictions
    let dateDomain: ClosedRange<Date>
    if let firstDate = sortedEntries.first?.date {
        let lastDate = sortedEntries.last?.date ?? firstDate
        let predictionEnd = Calendar.current.date(byAdding: .day, value: 14, to: lastDate) ?? lastDate
        dateDomain = firstDate...predictionEnd
    } else {
        dateDomain = Date()...Date()
    }

    cachedData = PreparedChartData(
        smoothed: smoothed,
        predictions: predictions,
        points: points,
        dateDomain: dateDomain
    )

    // Y-axis from ALL data (stable during scroll)
    let allWeights = points.map(\.weight) + smoothed.map(\.weight) + predictions.map(\.weight)
    if let minVal = allWeights.min(), let maxVal = allWeights.max() {
        cachedYMin = minVal - yAxisPadding
        cachedYMax = maxVal + yAxisPadding
    }
}
```

**4. Add `visibleDomainSeconds` computed property:**
Add this after the `yAxisPadding` computed property:
```swift
private var visibleDomainSeconds: TimeInterval {
    guard let days = selectedRange.days else {
        // "All" mode — show entire data span + predictions
        let sorted = entries.sorted { $0.date < $1.date }
        guard let first = sorted.first?.date, let last = sorted.last?.date else {
            return 604_800 // fallback: 7 days in seconds
        }
        let predictionEnd = Calendar.current.date(byAdding: .day, value: 14, to: last) ?? last
        return predictionEnd.timeIntervalSince(first)
    }
    // Range days + 14 days for prediction visibility at scroll end
    return TimeInterval((days + 14) * 86_400)
}
```

**5. Add `initialScrollDate` computed property:**
Add this after `visibleDomainSeconds`:
```swift
private var initialScrollDate: Date {
    let sorted = entries.sorted { $0.date < $1.date }
    guard let lastDate = sorted.last?.date else { return Date() }
    guard let days = selectedRange.days else {
        // "All" mode — start from beginning
        return sorted.first?.date ?? Date()
    }
    // Position chart so latest data is visible on the right side
    return Calendar.current.date(byAdding: .day, value: -(days + 14), to: lastDate) ?? lastDate
}
```

**6. Extract chart into a `private var chartContent: some View` computed property:**
Move the entire `Chart { ... }` block and ALL its modifiers (from `Chart {` through `.padding(.bottom)` and `.accessibilityChartDescriptor(self)`) out of `body` into a new computed property:
```swift
private var chartContent: some View {
    Chart {
        // ... all existing chart marks unchanged ...
    }
    .chartForegroundStyleScale([
        "Entry": AppColors.accent,
        "Trend": AppColors.chartTrend,
        "Predicted": AppColors.chartPredicted
    ])
    .chartYScale(domain: cachedYMin...cachedYMax)
    .chartXScale(domain: cachedData.dateDomain)
    .chartYAxis { /* ... existing Y axis unchanged ... */ }
    .chartXAxis { /* ... existing X axis unchanged ... */ }
    .chartXSelection(value: $selectedDate)
    // NEW: Add scrolling modifiers
    .chartScrollableAxes(.horizontal)
    .chartXVisibleDomain(length: visibleDomainSeconds)
    .chartScrollPosition(initialX: initialScrollDate)
    // NEW: Force chart re-creation when range changes (resets initialX)
    .id(selectedRange)
    // REMOVED: .animation(.snappy, value: selectedRange) — causes jank
    .padding(.bottom)
    .accessibilityChartDescriptor(self)
}
```

Then in `body`, replace the inline `Chart { ... }` and its modifiers with just:
```swift
var body: some View {
    VStack {
        selectionDisplay
        chartContent
    }
    .padding(.horizontal)
    .onAppear {
        recomputeChartData()
    }
    .onChange(of: dataFingerprint) { _, _ in recomputeChartData() }
    .onChange(of: weightUnit) { _, _ in recomputeChartData() }
    .onChange(of: showSmoothing) { _, _ in recomputeChartData() }
}
```

**7. Remove `.onChange(of: selectedRange)` (line 347):**
Since `recomputeChartData()` no longer references `selectedRange`, the onChange trigger is unnecessary. The `.id(selectedRange)` modifier on the chart forces SwiftUI to destroy and re-create the chart when the range changes, which triggers `.onAppear { recomputeChartData() }` on the re-created view. Since data doesn't depend on range, the recomputed data will be identical — this is intentional and harmless.

**8. REMOVE `.animation(.snappy, value: selectedRange)` (line 336):**
This line MUST be deleted. It was identified in research as a jank contributor. With `.id(selectedRange)` forcing chart re-creation, animation would apply to the destroy/create transition which looks wrong. Do NOT replace it with any other animation modifier.

**CRITICAL constraints:**
- NEVER use `chartScrollPosition(x: $binding)` — this is the reactive binding that caused jank in attempts 1-3
- ONLY use `chartScrollPosition(initialX:)` — the non-reactive version
- The `recomputeChartData()` function must NOT reference `selectedRange` at all
- The `dataFingerprint` already captures entry changes — that plus `weightUnit` and `showSmoothing` are the only onChange triggers needed
- Keep `.chartXSelection(value: $selectedDate)` — it should work with scrolling. If it doesn't (iOS 26 regression), the human verification step will catch this
  </action>
  <verify>
Build the project:
```bash
xcodebuild -project W8Trackr.xcodeproj -scheme W8Trackr -configuration Debug -sdk iphonesimulator build 2>&1 | tail -5
```

Verify these patterns exist in the file (grep confirms presence):
- `chartScrollableAxes(.horizontal)` is present
- `chartXVisibleDomain(length:` is present
- `chartScrollPosition(initialX:` is present
- `.id(selectedRange)` is present
- `struct ChartEntry: Identifiable, Equatable` is present
- `struct PreparedChartData: Equatable` is present

Verify these patterns do NOT exist (grep confirms absence):
- `chartScrollPosition(x: $` is NOT present (no reactive binding)
- `selectedRange.days` is NOT used inside `recomputeChartData()` (only in computed properties `visibleDomainSeconds` and `initialScrollDate`)
- `.onChange(of: selectedRange)` is NOT present
- `.animation(.snappy, value: selectedRange)` is NOT present
- `rangeEntries` is NOT present (old range-filtering variable)
- `sortedRangeEntries` is NOT present (old range-filtering variable)
- `rangeTrend` is NOT present (old range-filtering variable)
- `cutoffDate` is NOT present in `recomputeChartData()` (old range-filtering variable)
  </verify>
  <done>
WeightTrendChartView compiles successfully with:
- ALL entries always in the chart (no range filtering in recomputeChartData)
- Horizontal scrolling enabled via chartScrollableAxes(.horizontal)
- Visible window controlled by chartXVisibleDomain based on DateRange
- Non-reactive initial scroll position via chartScrollPosition(initialX:)
- `.id(selectedRange)` forces chart re-creation on range change (resets scroll position)
- `.animation(.snappy, value: selectedRange)` removed (jank contributor)
- `.onChange(of: selectedRange)` removed (data no longer depends on range)
- Y-axis computed from all data (stable during scroll)
- Chart body extracted into private `chartContent` computed property
- ChartEntry conforms to Equatable
- PreparedChartData conforms to Equatable
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify chart scroll performance on simulator</name>
  <what-built>Horizontal chart scrolling using non-reactive scroll position. The chart now contains ALL weight entries regardless of DateRange selection. The DateRange picker controls only the visible window width. `.id(selectedRange)` forces chart re-creation when the range changes, resetting the scroll position. The `.animation(.snappy)` modifier has been removed.</what-built>
  <how-to-verify>
    1. Build and run on iPhone 17 Pro simulator
    2. Add several weight entries across different dates if not already present
    3. On the dashboard, observe the Weight Chart section
    4. **Scroll performance test:**
       a. Select 1M — chart should show ~44 days visible window (30 + 14 for predictions)
       b. Swipe horizontally on chart — should scroll smoothly at 60fps without jank
       c. Verify Y-axis labels remain stable during scroll (no jumping or rescaling)
       d. Verify no console warnings about "onChange action tried to update multiple times per frame"
    5. **Tap-to-select test (HIGHEST RISK — may fail on iOS 26):**
       a. Tap on a data point in the chart — selection indicator should appear
       b. After scrolling, tap again — selection should still work
       c. **If tapping does NOT work:** This is the known iOS 18+ regression where `chartXSelection` + `chartScrollableAxes` conflict. Report "selection broken" and we will implement the `.chartGesture()` fallback in a gap closure plan.
    6. **DateRange switching test:**
       a. Select different ranges (1W, 1M, 3M, 6M, 1Y, All) — each should show the correct visible window width
       b. After scrolling in one range, switch to another — chart should reset to show most recent data (not stay at old scroll position)
       c. "All" should show all data without horizontal scrolling (or minimal scroll for predictions)
    7. **Vertical scroll test:**
       a. Scroll the entire page vertically — verify the chart's horizontal scroll does NOT block page scroll
       b. Diagonal swipes near the chart should feel natural (vertical movement should dominate)
    8. **Data integrity test:**
       a. In any range, scroll all the way to the left — you should see the earliest weight entries
       b. Scroll all the way to the right — you should see predictions extending past the last entry
       c. Verify the goal weight line is still visible across the entire scrollable range
  </how-to-verify>
  <resume-signal>Type "approved" if scrolling is smooth and all tests pass. If tap-to-select is broken, report "selection broken" so we can create a fallback plan. For any other issues, describe what you observed.</resume-signal>
</task>

</tasks>

<verification>
1. `xcodebuild build` succeeds with zero errors
2. `chartScrollableAxes(.horizontal)` present in WeightTrendChartView.swift
3. `chartScrollPosition(initialX:` present (non-reactive)
4. `chartScrollPosition(x: $` NOT present (no reactive binding)
5. `.id(selectedRange)` present on chart (forces re-creation on range change)
6. `.animation(.snappy, value: selectedRange)` NOT present (removed)
7. `.onChange(of: selectedRange)` NOT present (removed)
8. `recomputeChartData()` does not reference `selectedRange`
9. `ChartEntry` conforms to `Equatable`
10. `PreparedChartData` conforms to `Equatable`
11. Human verification: chart scrolls at 60fps without jank
12. Human verification: tap-to-select works (or regression documented)
13. Human verification: DateRange switching resets scroll position
</verification>

<success_criteria>
- Chart builds and renders with horizontal scrolling enabled
- ALL weight entries visible in chart (scrollable, not filtered)
- DateRange controls visible window width only
- No jank during scroll (non-reactive binding confirmed)
- Y-axis stable during scroll
- `.id(selectedRange)` resets scroll position on range change
- Tap selection works during/after scroll (or regression documented for gap closure)
- Vertical page scroll not blocked
</success_criteria>

<output>
After completion, create `.planning/phases/29-chart-scroll-performance/29-01-SUMMARY.md`
</output>
