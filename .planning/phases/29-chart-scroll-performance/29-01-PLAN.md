---
phase: 29-chart-scroll-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - W8Trackr/Views/WeightTrendChartView.swift
autonomous: false

must_haves:
  truths:
    - "Chart scrolls horizontally through all weight data without jank at 60fps"
    - "ALL weight entries are always in the chart regardless of DateRange selection"
    - "DateRange picker controls the visible window width, not which data is loaded"
    - "Y-axis remains stable during horizontal scroll (no jumping)"
    - "Tap-to-select still works during and after scrolling"
    - "Vertical page scroll is not blocked by chart horizontal scroll"
  artifacts:
    - path: "W8Trackr/Views/WeightTrendChartView.swift"
      provides: "Smooth scrollable weight trend chart"
      contains: "chartScrollableAxes(.horizontal)"
  key_links:
    - from: "recomputeChartData()"
      to: "cachedData"
      via: "ALL entries (no range filtering on data points)"
      pattern: "let sortedAllEntries = entries\\.sorted"
    - from: "DateRange.days"
      to: "chartXVisibleDomain"
      via: "visibleDomainSeconds computed property"
      pattern: "chartXVisibleDomain"
    - from: "chartScrollPosition"
      to: "initialX (non-binding)"
      via: "initialScrollDate computed property"
      pattern: "chartScrollPosition\\(initialX:"
---

<objective>
Enable smooth horizontal scrolling on the weight trend chart by separating the data layer (always ALL entries) from the scroll layer (non-reactive visible window controlled by DateRange).

Purpose: Three prior attempts failed because data filtering was coupled to scroll state. This plan decouples them: chart always contains ALL data points, DateRange only controls `chartXVisibleDomain` and initial scroll position via non-reactive `chartScrollPosition(initialX:)`.

Output: A single modified `WeightTrendChartView.swift` with smooth 60fps horizontal scrolling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@W8Trackr/Views/WeightTrendChartView.swift
@W8Trackr/Views/ChartSectionView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Decouple data layer from scroll layer and add horizontal scrolling</name>
  <files>W8Trackr/Views/WeightTrendChartView.swift</files>
  <action>
Modify `WeightTrendChartView.swift` with these specific changes:

**1. Make `ChartEntry` conform to `Equatable`:**
Add `Equatable` conformance to the `ChartEntry` struct (it already has all value-type properties, so synthesized conformance works). Also add `Equatable` conformance to `PreparedChartData`.

**2. Remove range filtering from `recomputeChartData()`:**
The function currently filters entries to `selectedRange.days`. Change it to use ALL entries for chart data:
- Replace `rangeEntries` with `entries` directly (sort all entries, not filtered ones)
- Remove the `if let days = selectedRange.days` block that creates `rangeEntries`
- For the smoothed trend: use ALL trend points (remove the cutoff filtering that filters `allTrend` to `rangeTrend`)
- For data points: use ALL sorted entries (not `sortedRangeEntries`)
- For the date domain: use the first entry's date from ALL sorted entries through prediction end

**3. Y-axis: compute from ALL data:**
The Y-axis range should use ALL data points (entries + smoothed + predictions) — not just range-filtered ones. This is already nearly correct since predictions use all data, but ensure the points and smoothed arrays are now unfiltered. This prevents Y-axis jumping during scroll.

**4. Remove `selectedRange` from `onChange` triggers:**
Since `recomputeChartData()` no longer uses `selectedRange` to filter data, remove the `.onChange(of: selectedRange)` call. The selectedRange now only affects `chartXVisibleDomain` and `chartScrollPosition(initialX:)`, both of which are computed properties that SwiftUI handles reactively.

**5. Add `visibleDomainSeconds` computed property:**
```swift
private var visibleDomainSeconds: TimeInterval {
    guard let days = selectedRange.days else {
        // "All" — compute full data span
        let sorted = entries.sorted { $0.date < $1.date }
        guard let first = sorted.first?.date, let last = sorted.last?.date else {
            return 604_800 // fallback: 7 days
        }
        let predictionEnd = Calendar.current.date(byAdding: .day, value: 14, to: last) ?? last
        return predictionEnd.timeIntervalSince(first)
    }
    // Add 14 days for prediction visibility when scrolled to end
    return TimeInterval((days + 14) * 86_400)
}
```

**6. Add `initialScrollDate` computed property:**
Returns the date the chart should initially scroll to so the most recent data is visible:
```swift
private var initialScrollDate: Date {
    let sorted = entries.sorted { $0.date < $1.date }
    guard let lastDate = sorted.last?.date else { return Date() }
    guard let days = selectedRange.days else {
        // "All" — start from beginning
        return sorted.first?.date ?? Date()
    }
    // Scroll so the latest entries are visible (position at start of visible window)
    return Calendar.current.date(byAdding: .day, value: -(days + 14), to: lastDate) ?? lastDate
}
```

**7. Add scroll modifiers to the Chart:**
After the existing `.chartXScale(domain: cachedData.dateDomain)` modifier, add:
```swift
.chartScrollableAxes(.horizontal)
.chartXVisibleDomain(length: visibleDomainSeconds)
.chartScrollPosition(initialX: initialScrollDate)
```

**8. Extract chart into a `private var chartContent` computed property:**
Move the `Chart { ... }` block and its modifiers into a separate computed property to isolate it from the outer `body`. This prevents unrelated state changes in body from triggering chart re-evaluation. The `body` should call `chartContent` instead of inlining the chart.

**CRITICAL constraints:**
- NEVER use `chartScrollPosition(x: $binding)` — this is the reactive binding that caused jank in attempt 1
- ONLY use `chartScrollPosition(initialX:)` — the non-reactive version
- The `recomputeChartData()` function must NOT reference `selectedRange` at all (it now processes ALL data)
- The `dataFingerprint` already captures entry changes — that is the only trigger needed along with `weightUnit` and `showSmoothing`
  </action>
  <verify>
Build the project:
```bash
xcodebuild -project W8Trackr.xcodeproj -scheme W8Trackr -configuration Debug -sdk iphonesimulator build 2>&1 | tail -5
```

Verify no compiler errors. Verify these patterns exist in the file:
- `chartScrollableAxes(.horizontal)` is present
- `chartXVisibleDomain(length:` is present
- `chartScrollPosition(initialX:` is present
- `chartScrollPosition(x:` is NOT present (grep confirms absence)
- `selectedRange.days` is NOT used inside `recomputeChartData()` (only in computed properties)
- `.onChange(of: selectedRange)` is NOT present
  </verify>
  <done>
WeightTrendChartView compiles successfully with:
- ALL entries always in the chart (no range filtering in recomputeChartData)
- Horizontal scrolling enabled via chartScrollableAxes(.horizontal)
- Visible window controlled by chartXVisibleDomain based on DateRange
- Non-reactive initial scroll position via chartScrollPosition(initialX:)
- Y-axis computed from all data (stable during scroll)
- Chart body isolated in private computed property
- ChartEntry and PreparedChartData conform to Equatable
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify chart scroll performance on simulator</name>
  <what-built>Horizontal chart scrolling using non-reactive scroll position. The chart now contains ALL weight entries regardless of DateRange selection. The DateRange picker controls only the visible window width.</what-built>
  <how-to-verify>
    1. Build and run on iPhone 17 Pro simulator
    2. Add several weight entries across different dates if not already present
    3. On the dashboard, observe the Weight Chart section
    4. Test each DateRange (1W, 1M, 3M, 6M, 1Y, All):
       a. Select 1M — chart should show ~30 days visible window, scrollable to earlier/later data
       b. Swipe horizontally on chart — should scroll smoothly at 60fps without jank
       c. Verify Y-axis labels remain stable during scroll (no jumping)
       d. Tap on chart to select a data point — selection indicator should appear
       e. After scrolling, tap should still work
    5. Scroll the entire page vertically — verify the chart's horizontal scroll does NOT block page scroll
    6. Select "All" — should show all data without scroll (or minimal scroll for predictions)
    7. Switch between DateRange options — visible window should resize, data remains complete
  </how-to-verify>
  <resume-signal>Type "approved" if scrolling is smooth, or describe any issues observed</resume-signal>
</task>

</tasks>

<verification>
1. `xcodebuild build` succeeds with zero errors
2. `chartScrollableAxes(.horizontal)` present in WeightTrendChartView.swift
3. `chartScrollPosition(initialX:` present (non-reactive)
4. `chartScrollPosition(x: $` NOT present (no reactive binding)
5. `recomputeChartData()` does not reference `selectedRange`
6. `ChartEntry` and `PreparedChartData` conform to `Equatable`
7. Human verification: chart scrolls at 60fps without jank
</verification>

<success_criteria>
- Chart builds and renders with horizontal scrolling enabled
- ALL weight entries visible in chart (scrollable, not filtered)
- DateRange controls visible window width only
- No jank during scroll (non-reactive binding confirmed)
- Y-axis stable during scroll
- Tap selection works during/after scroll
- Vertical page scroll not blocked
</success_criteria>

<output>
After completion, create `.planning/phases/29-chart-scroll-performance/29-01-SUMMARY.md`
</output>
